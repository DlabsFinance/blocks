// SPDX-License-Identifier: UNLICENSED
// strongly inspired by
// https://medium.com/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e
pragma solidity ^0.8.0;

library Math {
    uint256 constant exponent_table_length = 62;
    // these are split into 16 hex = 8 bytes
    // 512 = 8*64
    bytes constant exponent_table =
        '\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x01\x00\x0d\xe0\xb6\xb3\xa7\x64\x01\x80\x0d\xe0\xb6\xb3\xa7\x64\x02\x80\x0d\xe0\xb6\xb3\xa7\x64\x05\x00\x0d\xe0\xb6\xb3\xa7\x64\x0b\x80\x0d\xe0\xb6\xb3\xa7\x64\x16\x80\x0d\xe0\xb6\xb3\xa7\x64\x2c\x00\x0d\xe0\xb6\xb3\xa7\x64\x58\x80\x0d\xe0\xb6\xb3\xa7\x64\xb2\x00\x0d\xe0\xb6\xb3\xa7\x65\x63\x00\x0d\xe0\xb6\xb3\xa7\x66\xc5\x80\x0d\xe0\xb6\xb3\xa7\x69\x8c\x00\x0d\xe0\xb6\xb3\xa7\x6f\x17\x00\x0d\xe0\xb6\xb3\xa7\x7a\x2e\x80\x0d\xe0\xb6\xb3\xa7\x90\x5c\x80\x0d\xe0\xb6\xb3\xa7\xbc\xb8\x80\x0d\xe0\xb6\xb3\xa8\x15\x72\x80\x0d\xe0\xb6\xb3\xa8\xc6\xe4\x00\x0d\xe0\xb6\xb3\xaa\x29\xc8\x80\x0d\xe0\xb6\xb3\xac\xef\x91\x00\x0d\xe0\xb6\xb3\xb2\x7b\x22\x00\x0d\xe0\xb6\xb3\xbd\x92\x43\x00\x0d\xe0\xb6\xb3\xd3\xc0\x86\x00\x0d\xe0\xb6\xb4\x00\x1d\x0c\x00\x0d\xe0\xb6\xb4\x58\xd6\x17\x80\x0d\xe0\xb6\xb5\x0a\x48\x30\x00\x0d\xe0\xb6\xb6\x6d\x2c\x60\x80\x0d\xe0\xb6\xb9\x32\xf4\xc0\x80\x0d\xe0\xb6\xbe\xbe\x85\x84\x00\x0d\xe0\xb6\xc9\xd5\xa7\x10\x80\x0d\xe0\xb6\xe0\x03\xea\x45\x00\x0d\xe0\xb7\x0c\x60\x71\x17\x80\x0d\xe0\xb7\x65\x19\x80\x66\x80\x0d\xe0\xb8\x16\x8b\xa5\xa9\x80\x0d\xe0\xb9\x79\x70\x0a\xc6\x80\x0d\xe0\xbc\x3f\x39\x3f\x5b\x00\x0d\xe0\xc1\xca\xcd\x51\xee\x80\x0d\xe0\xcc\xe1\xfc\x1c\xc4\x00\x0d\xe0\xe3\x10\x74\x49\x40\x80\x0d\xe1\x0f\x6d\xce\xfe\x47\x00\x0d\xe1\x68\x2a\x2d\xde\xbc\x00\x0d\xe2\x19\xa9\x91\xaa\xdc\x00\x0d\xe3\x7c\xc2\xf2\xfc\xb7\x80\x0d\xe6\x43\x60\x28\xee\x3a\x00\x0d\xeb\xd2\x44\xc5\x55\xd4\x00\x0d\xf6\xf6\xb9\xdb\xcc\x5f\x80\x0e\x0d\x5a\x6c\x6e\xa8\xa8\x00\x0e\x3a\x8d\xbb\xd2\xb7\xea\x00\x0e\x96\xaa\x5b\xb8\x7c\x13\x80\x0f\x55\xef\x96\x06\x29\x19\x80\x10\xf2\x5d\xb8\x2c\x31\x7f\x00\x14\xb1\xc2\x44\x2f\xfa\xbe\x00\x1e\xdb\xf2\x5d\xe7\xa7\x10\x00\x44\x9e\x9d\xd0\x2d\x28\x18\x00';
    bytes constant powers_of_two =
        '\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00';
    uint256 constant decimals = 18;
    uint256 constant e_decimals = 10**decimals;

    function logarithm(uint256 operand) internal pure returns (uint256) {
        uint256 x = operand / e_decimals;
        require(x > 0, 'logarithm: operand too small');
        uint256 integer_part;
        if (x >= 2**128) {
            x >>= 128;
            integer_part += 128;
        }
        if (x >= 2**64) {
            x >>= 64;
            integer_part += 64;
        }
        if (x >= 2**32) {
            x >>= 32;
            integer_part += 32;
        }
        if (x >= 2**16) {
            x >>= 16;
            integer_part += 16;
        }
        if (x >= 2**8) {
            x >>= 8;
            integer_part += 8;
        }
        if (x >= 2**4) {
            x >>= 4;
            integer_part += 4;
        }
        if (x >= 2**2) {
            x >>= 2;
            integer_part += 2;
        }
        if (x >= 2**1) {
            /* x >>= 1; */
            integer_part += 1;
        }
        integer_part *= e_decimals;

        x = operand / (2**(integer_part / e_decimals));
        // 1 <= x < 2
        uint256 fractional_part;
        // log(x) = (1/2)*log(x^2)
        // log(x) = 1 + log(x/2)
        for (uint256 delta = e_decimals; delta > 0; delta /= 2) {
            // if x >= 2, use second identity, and halve
            if (x >= 2 * e_decimals) {
                fractional_part += delta;
                x /= 2;
            }
            // x < 2, use first identity
            x = (x * x) / e_decimals;
        }
        return fractional_part + integer_part;
    }

    function exponentiate(uint256 exponent) internal pure returns (uint256) {
        uint256 integer_part = exponent / e_decimals;
        uint256 fractional_part = exponent % e_decimals;
        uint256 integral_result = 2**integer_part * e_decimals;
        uint256 fractional_result = e_decimals;
        for (uint256 i = 0; i < exponent_table_length; i++) {
            if (power_of_two_lookup(i) & fractional_part > 0)
                fractional_result =
                    (fractional_result * exponent_table_lookup(i)) /
                    e_decimals;
        }
        return (integral_result * fractional_result) / e_decimals;
    }

    function exponent_table_lookup(uint256 index)
        internal
        pure
        returns (uint256)
    {
        bytes memory table = exponent_table;
        // we go 8 bytes at a time
        // skipping the first 32
        uint256 offset = 8 * index + 8;
        uint64 value;
        assembly {
            // 192 bits = 24 bytes = 256 - 64
            value := mload(add(table, offset))
            // exponent_value := mload(add(table, index))
        }
        return value;
    }

    function power_of_two_lookup(uint256 index)
        internal
        pure
        returns (uint256)
    {
        bytes memory table = powers_of_two;
        // we go 8 bytes at a time
        // skipping the first 32
        // which means starting at 8
        // to get the least significant 64 bits
        uint256 offset = 8 * index + 8;
        uint64 value;
        assembly {
            // 192 bits = 24 bytes = 256 - 64
            value := mload(add(table, offset))
            // exponent_value := mload(add(table, index))
        }
        return uint256(value);
    }
}
